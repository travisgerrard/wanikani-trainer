<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1a1a2e">
    <title>WK Trainer</title>
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon-192.png">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            padding: 16px;
            padding-top: env(safe-area-inset-top, 16px);
            padding-bottom: env(safe-area-inset-bottom, 16px);
        }

        h1 {
            text-align: center;
            color: #00d4ff;
            font-size: 1.3rem;
            margin-bottom: 8px;
        }

        .card {
            background: #16213e;
            border-radius: 16px;
            padding: 20px;
            margin: 12px 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .sentence {
            font-size: 1.6rem;
            line-height: 1.5;
            text-align: center;
            margin: 16px 0;
            min-height: 70px;
        }

        .blank {
            background: #00d4ff33;
            border-radius: 4px;
            padding: 2px 10px;
            border-bottom: 3px solid #00d4ff;
        }

        .english {
            color: #888;
            font-size: 0.95rem;
            text-align: center;
            font-style: italic;
            margin: 8px 0;
        }

        .word-info {
            text-align: center;
            padding: 16px;
            background: #0f3460;
            border-radius: 12px;
            margin: 16px 0;
        }

        .kanji { font-size: 2.2rem; color: #00d4ff; }
        .reading { font-size: 1.1rem; color: #aaa; margin-top: 4px; }
        .meaning { font-size: 1rem; color: #fff; margin-top: 6px; }

        .timer {
            text-align: center;
            font-size: 2.5rem;
            color: #ff6b6b;
            margin: 16px 0;
            transition: color 0.3s;
        }
        .timer.ready { color: #4ecdc4; }

        .instruction {
            text-align: center;
            color: #888;
            font-size: 0.85rem;
            margin: 8px 0;
        }

        button {
            display: block;
            width: 100%;
            padding: 14px;
            font-size: 1rem;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin: 6px 0;
            transition: all 0.15s;
            -webkit-tap-highlight-color: transparent;
        }

        button:active { transform: scale(0.98); }
        button:disabled { opacity: 0.4; }

        .reveal-btn { background: #00d4ff; color: #1a1a2e; font-weight: 600; }

        .rating-btns { display: flex; gap: 8px; }
        .rating-btns button { flex: 1; }
        .easy { background: #4ecdc4; color: #1a1a2e; }
        .medium { background: #ffe66d; color: #1a1a2e; }
        .hard { background: #ff6b6b; color: #fff; }

        /* Stats & Headers */
        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .brain-state {
            font-size: 0.75rem;
            padding: 4px 8px;
            border-radius: 12px;
            background: #0f3460;
            color: #888;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .brain-state.flow { color: #4ecdc4; border: 1px solid #4ecdc4; }
        .brain-state.lock { color: #ff6b6b; border: 1px solid #ff6b6b; }

        .streak-badge {
            font-size: 1.1rem;
            font-weight: bold;
            color: #ffe66d;
            text-shadow: 0 0 10px rgba(255, 230, 109, 0.5);
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .streak-badge.visible { opacity: 1; transform: scale(1); }

        .stats {
            display: flex;
            justify-content: space-around;
            padding: 12px;
            background: #0f3460;
            border-radius: 10px;
            margin-bottom: 12px;
        }

        .stat { text-align: center; }
        .stat-value { font-size: 1.3rem; color: #00d4ff; }
        .stat-label { font-size: 0.7rem; color: #888; }

        .progress {
            text-align: center;
            color: #666;
            font-size: 0.8rem;
            margin-top: 12px;
        }

        .hidden { display: none !important; }

        /* Animation classes */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-12px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes scaleIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        .animate-fade-in {
            animation: fadeIn 0.3s ease-out forwards;
        }

        .animate-slide-down {
            animation: slideDown 0.3s ease-out forwards;
        }

        .animate-scale-in {
            animation: scaleIn 0.25s ease-out forwards;
        }

        /* Smooth transitions for toggled elements */
        .sentence-image {
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .sentence {
            transition: opacity 0.3s ease;
        }

        .word-info {
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .setup {
            text-align: center;
            padding: 30px 20px;
        }

        .setup h2 { color: #00d4ff; margin-bottom: 20px; }
        .setup p { color: #888; margin: 12px 0; line-height: 1.5; }

        textarea {
            width: 100%;
            height: 150px;
            background: #0f3460;
            border: 2px solid #00d4ff33;
            border-radius: 10px;
            color: #fff;
            padding: 12px;
            font-size: 0.9rem;
            font-family: monospace;
            resize: vertical;
        }

        textarea:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .sync-status {
            text-align: center;
            font-size: 0.8rem;
            color: #4ecdc4;
            margin-top: 8px;
        }

        .offline-badge {
            position: fixed;
            top: env(safe-area-inset-top, 8px);
            right: 8px;
            background: #ff6b6b;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            z-index: 1000;
        }

        .ready-badge {
            position: fixed;
            top: env(safe-area-inset-top, 8px);
            right: 8px;
            background: #4ecdc4;
            color: #1a1a2e;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: bold;
            z-index: 1000;
        }

        .audio-btn {
            background: #0f3460;
            color: #00d4ff;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            padding: 18px 32px;
            margin: 6px 0;
            font-size: 1.1rem;
            font-weight: 600;
        }
        .audio-btn:disabled {
            color: #666;
        }
        .audio-btn svg {
            width: 28px;
            height: 28px;
            margin-right: 12px;
        }

        .audio-status {
            text-align: center;
            font-size: 0.75rem;
            color: #666;
            margin-top: 4px;
        }

        .sentence-image {
            width: 100%;
            max-width: 300px;
            height: auto;
            border-radius: 12px;
            margin: 12px auto;
            display: block;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .sentence-image.hidden {
            display: none;
        }

        .show-image-btn {
            background: #0f3460;
            color: #888;
            font-size: 0.8rem;
            padding: 8px 16px;
            margin: 8px auto;
            width: auto;
            display: block;
        }
        .show-image-btn:hover {
            color: #00d4ff;
        }
        .toggle-btns {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin: 8px auto;
        }
        .toggle-btns button {
            width: auto;
            flex: 0;
        }
    </style>
</head>
<body>
    <div id="offline-badge" class="offline-badge hidden">Offline</div>
    <div id="ready-badge" class="ready-badge hidden">Ready for Offline</div>

    <div class="top-bar">
        <h1>WK Trainer</h1>
        <div id="streak-badge" class="streak-badge">x2 Streak!</div>
    </div>

    <!-- Setup Screen -->
    <div id="setup" class="card setup">
        <h2>Load Practice Data</h2>
        <p>Paste your sentences.json content below, or it will try to load from the data folder.</p>
        <textarea id="json-input" placeholder='Paste JSON here or leave empty to auto-load...'></textarea>
        <button class="reveal-btn" onclick="loadData()" style="margin-top: 16px;">Start Training</button>
        <div id="sync-status" class="sync-status"></div>
    </div>

    <!-- Training Screen -->
    <div id="app" class="hidden">
        <div class="stats">
            <div class="stat">
                <div class="stat-value" id="active-count">0</div>
                <div class="stat-label">Active</div>
            </div>
             <div class="stat">
                <div class="stat-value" id="accuracy">-</div>
                <div class="stat-label">Brain Acc.</div>
            </div>
            <div class="stat">
                <div id="brain-state-display" class="brain-state">Loading...</div>
            </div>
        </div>

        <div class="card">
            <p class="instruction" id="phase-instruction">Predict the missing word...</p>
            <img id="sentence-image" class="sentence-image hidden" alt="Sentence illustration">
            <div id="toggle-btns" class="toggle-btns hidden">
                <button id="show-image-btn" class="show-image-btn hidden" onclick="toggleImage()">Show Image</button>
                <button id="show-sentence-btn" class="show-image-btn hidden" onclick="toggleSentence()">Show Sentence</button>
            </div>
            <div class="sentence" id="sentence"></div>
            <div class="english hidden" id="english"></div>

            <!-- Audio playback button -->
            <button class="audio-btn" id="play-audio-btn" onclick="playCurrentAudio()" style="display: none;">
                <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M8 5v14l11-7z"/>
                </svg>
                Play Audio
            </button>
            <div class="audio-status" id="audio-status"></div>

            <div id="timer-section">
                <div class="timer" id="timer">5</div>
                <p class="instruction">Think about what fits...</p>
            </div>

            <div id="reveal-section" class="hidden">
                <button class="reveal-btn" id="reveal-btn">Reveal Answer</button>
            </div>

            <div id="answer-section" class="hidden">
                <div class="word-info">
                    <div class="kanji" id="answer-word"></div>
                    <div class="reading" id="answer-reading"></div>
                    <div class="meaning" id="answer-meaning"></div>
                </div>

                <p class="instruction">How was your prediction?</p>
                <div class="rating-btns">
                    <button class="easy" onclick="rate('easy')">Easy</button>
                    <button class="medium" onclick="rate('medium')">Medium</button>
                    <button class="hard" onclick="rate('hard')">Hard</button>
                </div>
            </div>
        </div>
        <div class="progress" id="progress"></div>
        <div style="text-align: center; color: #444; font-size: 0.6rem; margin-top: 10px;">v1.8.0</div>
    </div>

    <!-- Complete Screen -->
    <div id="complete" class="card hidden">
        <h2 style="text-align: center; color: #4ecdc4; margin-bottom: 16px;">Queue Empty!</h2>
        <div class="stats">
            <div class="stat">
                <div class="stat-value" id="final-streak">0</div>
                <div class="stat-label">Max Streak</div>
            </div>
             <div class="stat">
                <div class="stat-value" id="final-acc">0%</div>
                <div class="stat-label">Session Acc</div>
            </div>
        </div>
        <p style="text-align: center; color:#888; margin:16px 0;">Check back later or add more sentences.</p>
        <button class="reveal-btn" onclick="restart()">Review Again</button>
        <button id="export-easy-btn" style="background: #4ecdc4; color: #1a1a2e; display: none;" onclick="exportEasyReviews()">
            Export Easy Reviews for WaniKani
        </button>
        <div id="export-status" class="sync-status"></div>
        <button style="background: #0f3460; color: #888;" onclick="resetData()">Load New Data</button>
    </div>

    <!-- Hidden audio element -->
    <audio id="audio-player" preload="auto"></audio>

    <script>
        // --- Constants ---
        // For prototype with 5 items, we use small numbers. 
        // Real app: GATING_WINDOW=100, LESSON_BATCH=10
        const GATING_WINDOW = 20; 
        const LESSON_BATCH_SIZE = 2;
        const UNLOCK_THRESHOLD = 0.9; // 90%
        const LOCK_THRESHOLD = 0.75; // 75%
        const SPEED_THRESHOLD = 1500; // 1.5s for dopamine bonus
        
        const STORAGE_KEY = 'wk_trainer_library';
        const STATE_KEY = 'wk_trainer_state'; 
        const EXPORT_KEY = 'wk_easy_reviews';

        // --- State ---
        let library = []; // All data loaded from JSON
        let audioManifest = [];
        let easyReviews = []; // Sync queue

        // Persistent User State
        let userState = {
            activeIds: [],   // list of subject_ids currently in rotation
            reviewHistory: [], // list of { t: timestamp, correct: bool, speed: ms }
            masteredIds: [], // subject_ids fully mastered
            imageHiddenIds: [], // subject_ids where image is hidden
            fullyMasteredIds: [], // subject_ids where sentence is hidden
            streak: 0,
            maxStreak: 0
        };

        // Session State
        let sessionQueue = []; // Array of { item, sentenceIndex }
        let currentCard = null;
        let timerInterval = null;
        let predictionStartTime = 0;
        let audioAvailable = false;

        const audioPlayer = document.getElementById('audio-player');

        // --- Offline / Audio Logic (Kept from original) ---
        function updateOnlineStatus() {
            const badge = document.getElementById('offline-badge');
            if (navigator.onLine) badge.classList.add('hidden');
            else badge.classList.remove('hidden');
        }
        window.addEventListener('online', updateOnlineStatus);
        window.addEventListener('offline', updateOnlineStatus);
        updateOnlineStatus();

        async function loadAudioManifest() {
            try {
                const response = await fetch('audio/manifest.json');
                if (response.ok) {
                    audioManifest = await response.json();
                    audioAvailable = audioManifest.length > 0;
                }
            } catch (e) { audioAvailable = false; }
        }

        function getAudioFile(word, sentenceIndex) {
            const entry = audioManifest.find(a => a.word === word && a.sentence_index === sentenceIndex);
            return entry ? `audio/${entry.file}` : null;
        }

        async function checkOfflineReadiness() {
            try {
                const manifestRes = await caches.match('audio/manifest.json');
                if (manifestRes) document.getElementById('ready-badge').classList.remove('hidden');
            } catch (e) {}
        }

        // --- Core Data Logic ---

        function saveState() {
            localStorage.setItem(STATE_KEY, JSON.stringify(userState));
        }

        function getRecentAccuracy() {
            const history = userState.reviewHistory.slice(-GATING_WINDOW);
            if (history.length === 0) return 0;
            const correct = history.filter(h => h.correct).length;
            return correct / history.length;
        }

        function getBrainState() {
            const acc = getRecentAccuracy();
            const historyLen = userState.reviewHistory.length;
            
            // Need some history to determine state
            if (historyLen < 5) return 'learning';

            if (acc >= UNLOCK_THRESHOLD) return 'flow';
            if (acc < LOCK_THRESHOLD) return 'lock';
            return 'learning';
        }

        function replenishQueue() {
            // 1. Identify which items are active
            const activeItems = library.filter(i => userState.activeIds.includes(i.subject_id));
            
            // 2. Build a queue from active items
            // Simple logic: Add all sentences of active items
            // In a real SRS, this would check due dates. Here we just rotate active items.
            let newQueue = [];
            activeItems.forEach(item => {
                item.sentences.forEach((s, idx) => {
                    newQueue.push({ item: item, sentenceIndex: idx });
                });
            });

            // Shuffle
            newQueue.sort(() => Math.random() - 0.5);
            sessionQueue = newQueue;
        }

        function checkLevelUp() {
            const state = getBrainState();
            const activeCount = userState.activeIds.length;
            const libraryCount = library.length;

            if (state === 'lock') {
                // Locked: focus on current active items
                return; 
            }

            // If we are in Flow (or just starting and have room), try to add lessons
            // "Actor" Logic: Ungate lessons if high accuracy
            if (state === 'flow' || activeCount === 0) {
                const potentialLessons = library.filter(i => !userState.activeIds.includes(i.subject_id));
                
                if (potentialLessons.length > 0) {
                    // Add batch
                    const toAdd = potentialLessons.slice(0, LESSON_BATCH_SIZE);
                    toAdd.forEach(i => userState.activeIds.push(i.subject_id));
                    console.log(`Leveled Up! Added ${toAdd.length} new items.`);
                    
                    // Trigger a re-shuffle to include them immediately? 
                    // For now, they'll appear next "restart" or we could inject them.
                    // Let's inject them into the BACK of the current session queue
                    toAdd.forEach(item => {
                        item.sentences.forEach((s, idx) => {
                            sessionQueue.push({ item: item, sentenceIndex: idx });
                        });
                    });
                }
            }
        }

        // --- UI Logic ---

        function updateUIStats() {
            // Accuracy
            const acc = Math.round(getRecentAccuracy() * 100);
            document.getElementById('accuracy').textContent = `${acc}%`;
            
            // Active Count
            document.getElementById('active-count').textContent = userState.activeIds.length;

            // Brain State
            const state = getBrainState();
            const stateEl = document.getElementById('brain-state-display');
            if (state === 'flow') {
                stateEl.textContent = 'âš¡ Flow State';
                stateEl.className = 'brain-state flow';
            } else if (state === 'lock') {
                stateEl.textContent = 'ðŸ”’ Locked';
                stateEl.className = 'brain-state lock';
            } else {
                stateEl.textContent = 'ðŸ§  Learning';
                stateEl.className = 'brain-state';
            }

            // Streak
            const streakBadge = document.getElementById('streak-badge');
            if (userState.streak > 1) {
                streakBadge.textContent = `x${userState.streak} Streak!`;
                streakBadge.classList.add('visible');
            } else {
                streakBadge.classList.remove('visible');
            }
        }

        async function loadData() {
            const input = document.getElementById('json-input').value.trim();
            const statusEl = document.getElementById('sync-status');

            try {
                // Load raw data (Library)
                if (input) {
                    library = JSON.parse(input);
                    statusEl.textContent = 'Loaded from paste';
                } else {
                    const cached = localStorage.getItem(STORAGE_KEY);
                    if (cached) {
                        library = JSON.parse(cached);
                        statusEl.textContent = 'Loaded from cache';
                    } else {
                        let response = await fetch('sentences.json').catch(() => null);
                        if (!response || !response.ok) response = await fetch('../data/sentences.json').catch(() => null);
                        if (!response || !response.ok) throw new Error('No data file found');
                        library = await response.json();
                        statusEl.textContent = 'Loaded from file';
                    }
                }

                // Filter valid
                library = library.filter(item => item.sentences && item.sentences.length > 0);
                localStorage.setItem(STORAGE_KEY, JSON.stringify(library));

                // Load User State
                const savedState = localStorage.getItem(STATE_KEY);
                if (savedState) {
                    userState = JSON.parse(savedState);
                } else {
                    // Init: If no state, take first batch as active
                    const initialBatch = library.slice(0, 3); // Start with 3 items
                    userState.activeIds = initialBatch.map(i => i.subject_id);
                }

                await loadAudioManifest();
                
                // Initialize Session
                replenishQueue();

                // Setup UI
                document.getElementById('setup').classList.add('hidden');
                document.getElementById('app').classList.remove('hidden');
                updateUIStats();
                showCard();

            } catch (e) {
                statusEl.textContent = 'Error: ' + e.message;
                statusEl.style.color = '#ff6b6b';
                console.error(e);
            }
        }

        function showCard() {
            if (sessionQueue.length === 0) {
                showComplete();
                return;
            }

            // Pop next card
            currentCard = sessionQueue.shift();
            const { item, sentenceIndex } = currentCard;
            const sentence = item.sentences[sentenceIndex];

            // Setup UI Visibility based on Mastery
            const imageEl = document.getElementById('sentence-image');
            const showImageBtn = document.getElementById('show-image-btn');
            const showSentenceBtn = document.getElementById('show-sentence-btn');
            const toggleBtns = document.getElementById('toggle-btns');
            
            const isImageHidden = userState.imageHiddenIds.includes(item.subject_id) || userState.fullyMasteredIds.includes(item.subject_id);
            const isFullyMastered = userState.fullyMasteredIds.includes(item.subject_id);

            // Reset UI
            toggleBtns.classList.add('hidden');
            showImageBtn.classList.add('hidden');
            showSentenceBtn.classList.add('hidden');

            const sentenceEl = document.getElementById('sentence');
            const englishEl = document.getElementById('english');
            const answerSection = document.getElementById('answer-section');

            const timerSection = document.getElementById('timer-section');

            // Reset animation classes so they can re-trigger
            sentenceEl.classList.remove('animate-fade-in', 'animate-slide-down', 'animate-scale-in');
            englishEl.classList.remove('animate-fade-in', 'animate-slide-down', 'animate-scale-in');
            answerSection.classList.remove('animate-fade-in', 'animate-slide-down', 'animate-scale-in');
            imageEl.classList.remove('animate-fade-in', 'animate-slide-down', 'animate-scale-in');
            timerSection.classList.remove('animate-fade-in', 'animate-slide-down', 'animate-scale-in');

            const revealSection = document.getElementById('reveal-section');
            revealSection.classList.remove('animate-fade-in', 'animate-slide-down', 'animate-scale-in');

            sentenceEl.classList.add('hidden');
            englishEl.classList.add('hidden');
            timerSection.classList.add('hidden');
            revealSection.classList.add('hidden');
            answerSection.classList.add('hidden');
            document.getElementById('phase-instruction').textContent = 'Listen to the sentence...';

            // Image logic
            if (sentence.image) {
                imageEl.src = sentence.image;
                if (isImageHidden) {
                    imageEl.classList.add('hidden');
                    showImageBtn.classList.remove('hidden');
                    showImageBtn.textContent = 'Show Image';
                    toggleBtns.classList.remove('hidden');
                } else {
                    imageEl.classList.remove('hidden');
                }
            } else {
                imageEl.classList.add('hidden');
            }

            // Sentence logic
            if (isFullyMastered) {
                showSentenceBtn.classList.remove('hidden');
                showSentenceBtn.textContent = 'Show Sentence';
                toggleBtns.classList.remove('hidden');
            }

            // Answer info
            document.getElementById('answer-word').textContent = item.word;
            document.getElementById('answer-reading').textContent = item.reading;
            document.getElementById('answer-meaning').textContent = item.meaning;

            // Audio Playback
            const audioFile = getAudioFile(item.word, sentenceIndex);
            const audioBtn = document.getElementById('play-audio-btn');

            const startPredictionPhase = () => {
                // Prepare sentence text
                const blankSentence = sentence.japanese.replace(item.word, '<span class="blank">???</span>');
                const sentenceEl = document.getElementById('sentence');
                sentenceEl.innerHTML = blankSentence;
                document.getElementById('english').textContent = sentence.english;

                if (!isFullyMastered) {
                    sentenceEl.classList.remove('hidden');
                    sentenceEl.classList.add('animate-fade-in');
                    document.getElementById('phase-instruction').textContent = 'Predict the missing word...';
                } else {
                    document.getElementById('phase-instruction').textContent = 'Listen and predict...';
                }

                const timerSection = document.getElementById('timer-section');
                timerSection.classList.remove('hidden');
                timerSection.classList.add('animate-fade-in');

                // Track start time for speed bonus
                predictionStartTime = Date.now();
                startTimer();
            };

            if (audioFile && audioAvailable) {
                audioBtn.style.display = 'inline-flex';
                audioPlayer.src = audioFile;
                audioPlayer.onended = startPredictionPhase;
                audioPlayer.play().catch(() => startPredictionPhase());
            } else {
                audioBtn.style.display = 'none';
                setTimeout(startPredictionPhase, 500);
            }
            
            updateUIStats();
        }

        function startTimer() {
            let seconds = 5;
            const timerEl = document.getElementById('timer');
            timerEl.textContent = seconds;
            timerEl.classList.remove('ready');
            if (timerInterval) clearInterval(timerInterval);

            timerInterval = setInterval(() => {
                seconds--;
                if (seconds > 0) {
                    timerEl.textContent = seconds;
                } else {
                    clearInterval(timerInterval);
                    timerEl.textContent = 'âœ“';
                    timerEl.classList.add('ready');
                    // Auto reveal after timeout? No, user must reveal to confirm prediction.
                    // But we enable reveal button visibility if hidden
                    document.getElementById('timer-section').classList.add('hidden');
                    const revealSection = document.getElementById('reveal-section');
                    revealSection.classList.remove('hidden');
                    revealSection.classList.add('animate-scale-in');
                    document.getElementById('phase-instruction').textContent = 'Ready?';
                }
            }, 1000);
        }

        // Toggles
        function toggleImage() {
            const el = document.getElementById('sentence-image');
            const btn = document.getElementById('show-image-btn');
            el.classList.toggle('hidden');
            btn.textContent = el.classList.contains('hidden') ? 'Show Image' : 'Hide Image';
        }
        function toggleSentence() {
            const el = document.getElementById('sentence');
            const btn = document.getElementById('show-sentence-btn');
            el.classList.toggle('hidden');
            btn.textContent = el.classList.contains('hidden') ? 'Show Sentence' : 'Hide Sentence';
        }

        // Reveal
        document.getElementById('reveal-btn').addEventListener('click', () => {
            const duration = Date.now() - predictionStartTime;
            const { item, sentenceIndex } = currentCard;
            const sentence = item.sentences[sentenceIndex];

            // Stop timer
            if (timerInterval) clearInterval(timerInterval);

            // Show full sentence with animation
            const sentenceEl = document.getElementById('sentence');
            sentenceEl.innerHTML = sentence.japanese;
            sentenceEl.classList.remove('hidden');
            sentenceEl.classList.add('animate-fade-in');

            const englishEl = document.getElementById('english');
            englishEl.classList.remove('hidden');
            englishEl.classList.add('animate-fade-in');

            // Show image if available with animation
            if (sentence.image) {
                const imageEl = document.getElementById('sentence-image');
                imageEl.classList.remove('hidden');
                imageEl.classList.add('animate-scale-in');
            }

            document.getElementById('reveal-section').classList.add('hidden');

            // Show answer section with animation
            const answerSection = document.getElementById('answer-section');
            answerSection.classList.remove('hidden');
            answerSection.classList.add('animate-slide-down');

            document.getElementById('phase-instruction').textContent = 'How was your prediction?';

            // Store duration on the button for the rating handler
            answerSection.dataset.duration = duration;
        });

        function rate(rating) {
            const duration = parseInt(document.getElementById('answer-section').dataset.duration || '5000');
            const isCorrect = (rating === 'easy' || rating === 'medium');
            const { item } = currentCard;
            
            // 1. Update History
            userState.reviewHistory.push({
                t: Date.now(),
                correct: isCorrect,
                speed: duration
            });
            // Keep history manageable
            if (userState.reviewHistory.length > 200) userState.reviewHistory.shift();

            // 2. Streak & Speed Bonus
            if (isCorrect) {
                if (duration < SPEED_THRESHOLD) {
                    // Fast! Dopamine hit.
                    userState.streak++;
                } else {
                    // Correct but slow - maintain or increment?
                    // User request: "Streak multiplier only if... under 1.5 seconds"
                    // Implies streak breaks or doesn't increase if slow? 
                    // Let's say it doesn't increase, or maybe resets if really slow?
                    // For now: Streak only increments on FAST. Resets on ERROR.
                    // If correct but slow, streak stays same (or maybe decays?)
                    // Let's implement strict: Streak only builds on speed.
                }
            } else {
                userState.streak = 0;
            }
            if (userState.streak > userState.maxStreak) userState.maxStreak = userState.streak;

            // 3. Mastery State (Easy/Medium/Hard logic)
            if (rating === 'medium') {
                if (!userState.imageHiddenIds.includes(item.subject_id)) {
                    userState.imageHiddenIds.push(item.subject_id);
                }
            }
            if (rating === 'easy') {
                if (!userState.fullyMasteredIds.includes(item.subject_id)) {
                    userState.fullyMasteredIds.push(item.subject_id);
                    // Add to sync queue
                    if (!easyReviews.find(r => r.subject_id === item.subject_id)) {
                        easyReviews.push({
                            subject_id: item.subject_id,
                            word: item.word,
                            reading: item.reading,
                            meaning: item.meaning
                        });
                    }
                }
            }
            // Hard resets mastery?
            if (rating === 'hard') {
                userState.fullyMasteredIds = userState.fullyMasteredIds.filter(id => id !== item.subject_id);
                userState.imageHiddenIds = userState.imageHiddenIds.filter(id => id !== item.subject_id);
            }

            // 4. Check Gating / Level Up
            checkLevelUp();

            // 5. Save & Next
            saveState();
            showCard();
        }

        function playCurrentAudio() {
            // Helper to replay audio
            if (!currentCard) return;
            const { item, sentenceIndex } = currentCard;
            const file = getAudioFile(item.word, sentenceIndex);
            if (file) {
                audioPlayer.src = file;
                audioPlayer.play();
            }
        }

        function showComplete() {
            document.getElementById('app').classList.add('hidden');
            document.getElementById('complete').classList.remove('hidden');
            
            document.getElementById('final-streak').textContent = userState.maxStreak;
            
            // Session Accuracy
            // Simple calculation: last N items match session size approx
            // Or just use recent history
            const acc = Math.round(getRecentAccuracy() * 100);
            document.getElementById('final-acc').textContent = acc + '%';

            // Export btn
            if (easyReviews.length > 0) {
                document.getElementById('export-easy-btn').style.display = 'block';
                document.getElementById('export-status').textContent = `${easyReviews.length} items to sync`;
            }
        }

        function restart() {
            // Replenish queue and go again
            replenishQueue();
            document.getElementById('complete').classList.add('hidden');
            document.getElementById('app').classList.remove('hidden');
            showCard();
        }

        function resetData() {
            if(confirm("Reset all progress?")) {
                localStorage.removeItem(STORAGE_KEY);
                localStorage.removeItem(STATE_KEY);
                location.reload();
            }
        }

        function exportEasyReviews() {
             if (easyReviews.length === 0) return;
            const exportData = JSON.stringify(easyReviews, null, 2);
            localStorage.setItem(EXPORT_KEY, exportData);
            
            const blob = new Blob([exportData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'easy_reviews.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            easyReviews = [];
            document.getElementById('export-easy-btn').style.display = 'none';
            document.getElementById('export-status').textContent = 'Exported!';
        }

        // Init
        window.addEventListener('load', () => {
            checkOfflineReadiness();
            loadData();
        });

        // SW
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').then(reg => {
                navigator.serviceWorker.addEventListener('message', event => {
                    if (event.data?.type === 'OFFLINE_READY') document.getElementById('ready-badge').classList.remove('hidden');
                });
            });
        }
    </script>
</body>
</html>